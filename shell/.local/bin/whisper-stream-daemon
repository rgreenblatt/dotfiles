#!/usr/bin/env python3
"""Whisper streaming daemon - runs whisper-stream and types output via xdotool.

Handles corrections by tracking typed text and using backspace to correct.
Detects segment boundaries to accumulate text properly.
On shutdown, does a final cleanup pass using whisper-cli on the full recording.

Usage:
    whisper-stream-daemon [--debug]

    --debug: Print output instead of typing (for testing)
"""

import subprocess
import os
import sys
import signal
import re
import time

DEBUG_MODE = "--debug" in sys.argv

MODEL = os.environ.get(
    "WHISPER_MODEL",
    os.path.expanduser("~/.local/share/whisper.cpp/ggml-large-v3-turbo.bin"),
)
PROMPT_FILE = os.path.expanduser("~/.config/whisper/prompt.txt")
PID_FILE = "/tmp/whisper-stream.pid"
STATE_FILE = "/tmp/whisper-stream-state"
AUDIO_FILE = "/tmp/whisper-stream-audio.wav"

# Streaming parameters
STEP_MS = 2000  # How often to process audio (ms)
LENGTH_MS = 8000  # Audio window length (ms)
KEEP_MS = 1000  # Overlap to keep for context (ms)


def get_prompt() -> str | None:
    """Load whisper prompt if available."""
    if os.path.exists(PROMPT_FILE):
        with open(PROMPT_FILE) as f:
            prompt = f.read().strip()
            return prompt if prompt else None
    return None


def type_text(text: str):
    """Type text using xdotool (or print in debug mode)."""
    if text:
        if DEBUG_MODE:
            sys.stderr.write(f"[TYPE] +'{text}'\n")
        else:
            subprocess.run(
                ["xdotool", "type", "--clearmodifiers", "--delay", "0", "--", text],
                check=False,
            )


def delete_chars(n: int):
    """Delete n characters using backspace (or print in debug mode)."""
    if n > 0:
        if DEBUG_MODE:
            sys.stderr.write(f"[DEL] {n} chars\n")
        else:
            chunk_size = 50
            remaining = n
            while remaining > 0:
                batch = min(remaining, chunk_size)
                subprocess.run(
                    ["xdotool", "key", "--clearmodifiers", "--delay", "0"]
                    + ["BackSpace"] * batch,
                    check=False,
                )
                remaining -= batch


def save_state(finalized: str, current: str):
    """Save state for debugging/recovery."""
    with open(STATE_FILE, "w") as f:
        f.write(f"finalized:{len(finalized)}\n{finalized}\n---\ncurrent:{len(current)}\n{current}")


def find_common_prefix(s1: str, s2: str) -> str:
    """Find the longest common prefix between two strings."""
    min_len = min(len(s1), len(s2))
    for i in range(min_len):
        if s1[i] != s2[i]:
            return s1[:i]
    return s1[:min_len]


def is_new_segment(old_text: str, new_text: str) -> bool:
    """Detect if new_text represents a new segment."""
    if not old_text:
        return False
    common = find_common_prefix(old_text, new_text)
    if len(common) < 10 and len(old_text) > 20:
        return True
    if len(old_text) > 0 and len(common) / len(old_text) < 0.2:
        return True
    return False


def final_cleanup(total_typed: str):
    """Do a final cleanup pass using whisper-cli on the full recording.

    Delete what was typed and replace with the final transcription if different.
    """
    if not os.path.exists(AUDIO_FILE):
        return

    if os.path.getsize(AUDIO_FILE) < 1000:
        return

    # Build whisper-cli command
    cmd = ["whisper-cli", "-m", MODEL, "-f", AUDIO_FILE, "--no-timestamps", "-np"]

    prompt = get_prompt()
    if prompt:
        cmd.extend(["--prompt", prompt])

    result = subprocess.run(cmd, capture_output=True, text=True)
    final_text = result.stdout.strip()

    if not final_text:
        return

    # Compare and update if different
    if final_text != total_typed:
        # Find common prefix to minimize edits
        common = find_common_prefix(total_typed, final_text)
        to_delete = len(total_typed) - len(common)
        to_add = final_text[len(common):]

        if to_delete > 0:
            delete_chars(to_delete)
        if to_add:
            type_text(to_add)


def run_streaming():
    """Run whisper-stream and handle output."""
    # Start recording audio for final cleanup pass
    if os.path.exists(AUDIO_FILE):
        os.unlink(AUDIO_FILE)

    rec_proc = subprocess.Popen(
        ["rec", "-q", "-r", "16000", "-c", "1", AUDIO_FILE],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )

    # Start whisper-stream
    cmd = [
        "whisper-stream",
        "-m", MODEL,
        "--step", str(STEP_MS),
        "--length", str(LENGTH_MS),
        "--keep", str(KEEP_MS),
        "--keep-context",
        "-l", "en",
    ]

    env = os.environ.copy()
    env["SDL_AUDIODRIVER"] = "pulseaudio"

    proc = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        env=env,
        bufsize=1,
    )

    # Track state
    finalized_text = ""
    current_segment = ""
    typed_current = ""

    ansi_clear = re.compile(r"\x1b\[2K|\r")
    shutdown = False

    def handle_signal(signum, frame):
        nonlocal shutdown
        shutdown = True

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    try:
        while not shutdown:
            if not proc.stdout:
                break
            line = proc.stdout.readline()
            if not line:
                if proc.poll() is not None:
                    break
                continue

            line = ansi_clear.sub("", line).strip()

            if not line:
                continue
            if line.startswith("[") or line.startswith("init:") or line.startswith("main:"):
                continue
            if line.startswith("whisper_"):
                continue

            new_text = line

            if is_new_segment(current_segment, new_text):
                finalized_text += typed_current
                if typed_current and not typed_current.endswith(" "):
                    type_text(" ")
                    finalized_text += " "
                current_segment = ""
                typed_current = ""

            if new_text != current_segment:
                current_segment = new_text
                common = find_common_prefix(typed_current, new_text)
                to_delete = len(typed_current) - len(common)
                to_add = new_text[len(common):]

                if to_delete > 0:
                    delete_chars(to_delete)
                if to_add:
                    type_text(to_add)

                typed_current = new_text
                save_state(finalized_text, typed_current)

    except Exception as e:
        sys.stderr.write(f"Error: {e}\n")
    finally:
        # Stop whisper-stream
        proc.terminate()
        try:
            proc.wait(timeout=2)
        except subprocess.TimeoutExpired:
            proc.kill()

        # Stop recording
        rec_proc.send_signal(signal.SIGINT)
        try:
            rec_proc.wait(timeout=2)
        except subprocess.TimeoutExpired:
            rec_proc.kill()

        # Give a moment for file to be written
        time.sleep(0.1)

        # Do final cleanup pass
        total_typed = finalized_text + typed_current
        final_cleanup(total_typed)

        # Clean up
        if os.path.exists(STATE_FILE):
            os.unlink(STATE_FILE)
        if os.path.exists(AUDIO_FILE):
            os.unlink(AUDIO_FILE)

        # Notify completion (after cleanup)
        if not DEBUG_MODE:
            subprocess.run(
                ["notify-send", "-u", "low", "-t", "500", "Whisper", "Done"],
                check=False,
            )


def main():
    with open(PID_FILE, "w") as f:
        f.write(str(os.getpid()))

    try:
        run_streaming()
    finally:
        if os.path.exists(PID_FILE):
            os.unlink(PID_FILE)


if __name__ == "__main__":
    main()
